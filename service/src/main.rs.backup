#![windows_subsystem = "windows"]

use eframe::egui;
use std::sync::Arc;
use tokio::sync::RwLock;

mod cli;
mod config;
mod ec;
mod types;

// Re-export for convenience
use types::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    run_gui().map_err(|e| e.into())
}

fn run_gui() -> Result<(), eframe::Error> {
    // Simple .env file loading
    if let Ok(content) = std::fs::read_to_string(".env") {
        for line in content.lines() {
            let line = line.trim();
            if line.is_empty() || line.starts_with('#') {
                continue;
            }
            if let Some(pos) = line.find('=') {
                let key = line[..pos].trim();
                let value = line[pos + 1..].trim().trim_matches('"').trim_matches('\'');
                std::env::set_var(key, value);
            }
        }
    }

    // Create app state
    let runtime = tokio::runtime::Runtime::new().unwrap();
    let state = runtime.block_on(async { AppState::initialize().await });

    // Start background data poller (Performance Fix)
    let state_clone_poll = state.clone();
    runtime.spawn(async move {
        loop {
            if let Some(ft) = state_clone_poll.framework_tool.read().await.as_ref() {
                let mut cache = state_clone_poll.cache.write().await;

                if let Ok(thermal) = ft.read_thermal().await {
                    cache.thermal = Some(thermal);
                }
                if let Ok(power) = ft.read_power_info().await {
                    cache.power = Some(power);
                }
                if cache.versions.is_none() {
                    if let Ok(v) = ft.read_versions().await {
                        cache.versions = Some(v);
                    }
                }
            }
            tokio::time::sleep(std::time::Duration::from_millis(1000)).await;
        }
    });

    // Launch GUI
    let args: Vec<String> = std::env::args().collect();
    let start_minimized = args.iter().any(|a| a == "--minimized");

    let options = eframe::NativeOptions {
        viewport: egui::ViewportBuilder::default()
            .with_inner_size([1000.0, 700.0])
            .with_min_inner_size([800.0, 600.0])
            .with_icon(load_icon())
            .with_visible(!start_minimized),
        ..Default::default()
    };

    eframe::run_native(
        "Framework Control",
        options,
        Box::new(|cc| Ok(Box::new(FrameworkControlApp::new(cc, state, runtime)))),
    )
}

fn load_icon() -> egui::IconData {
    // 32x32 Framework Gear Icon
    let width = 32;
    let height = 32;
    let mut rgba = vec![0u8; (width * height * 4) as usize];

    let center_x = width as f32 / 2.0;
    let center_y = height as f32 / 2.0;
    let radius = 14.0;

    // Framework Orange
    let orange = [255, 106, 0, 255];
    // Dark Grey for the "F"
    let dark = [30, 30, 30, 255];

    for y in 0..height {
        for x in 0..width {
            let idx = ((y * width + x) * 4) as usize;
            let dx = x as f32 - center_x;
            let dy = y as f32 - center_y;
            let dist = (dx * dx + dy * dy).sqrt();
            let angle = dy.atan2(dx);

            // Gear teeth (12 teeth)
            let teeth = (angle * 12.0).cos();
            let gear_radius = radius + teeth * 1.5;

            if dist <= gear_radius {
                // Main gear body
                rgba[idx..idx + 4].copy_from_slice(&orange);

                // "F" cutout (simplified)
                if x >= 12 && x <= 16 && y >= 8 && y <= 24 {
                    rgba[idx..idx + 4].copy_from_slice(&dark);
                } // Vertical
                if x >= 16 && x <= 22 && y >= 8 && y <= 12 {
                    rgba[idx..idx + 4].copy_from_slice(&dark);
                } // Top bar
                if x >= 16 && x <= 20 && y >= 16 && y <= 19 {
                    rgba[idx..idx + 4].copy_from_slice(&dark);
                } // Mid bar
            }

            // Antialiasing/Transparency for outside
            if dist > gear_radius {
                rgba[idx + 3] = 0;
            }
        }
    }

    egui::IconData {
        rgba,
        width,
        height,
    }
}

// Application state
#[derive(Clone)]
pub struct AppState {
    pub framework_tool: Arc<RwLock<Option<cli::FrameworkTool>>>,
    pub config: Arc<RwLock<Config>>,
    pub telemetry_samples: Arc<RwLock<std::collections::VecDeque<TelemetrySample>>>,
    pub cache: Arc<RwLock<CachedData>>,
}

#[derive(Default, Clone)]
pub struct CachedData {
    pub thermal: Option<cli::::ThermalParsed>,
    pub power: Option<cli::framework_tool::PowerBatteryInfo>,
    pub versions: Option<cli::framework_tool::Versions>,
}

impl AppState {
    pub async fn initialize() -> Self {
        let config = Arc::new(RwLock::new(config::load()));

        let framework_tool = Arc::new(RwLock::new(Some(cli::FrameworkTool::new().await)));
        Self::spawn_framework_tool_resolver(framework_tool.clone());

        let cache = Arc::new(RwLock::new(CachedData::default()));

        Self {
            framework_tool,
            config,
            telemetry_samples: Arc::new(RwLock::new(Default::default())),
            cache,
        }
    }

    fn spawn_framework_tool_resolver(ft_lock: Arc<RwLock<Option<cli::FrameworkTool>>>) {
        tokio::spawn(async move {
            use tokio::time::{sleep, Duration};
            let mut _consecutive_errors = 0u32;
            loop {
                let current = { ft_lock.read().await.clone() };
                match current {
                    Some(cli) => {
                        if let Err(e) = cli.read_versions().await {
                            *ft_lock.write().await = None;
                            tracing::warn!("framework_tool unavailable ({})", e);
                            _consecutive_errors = 0;
                        }
                    }
                    None => {
                        let cli = cli::FrameworkTool::new().await;
                        *ft_lock.write().await = Some(cli);
                        tracing::info!("framework_tool is now available");
                        _consecutive_errors = 0;
                    }
                }
                sleep(Duration::from_secs(5)).await;
            }
        });
    }
}

// Background tasks module
mod tasks {
    use super::*;

    pub async fn boot(state: &AppState) {
        // Fan curve task
        {
            let ft_clone = state.framework_tool.clone();
            let cfg_clone = state.config.clone();
            tokio::spawn(async move {
                fan_curve::run(ft_clone, cfg_clone).await;
            });
        }

        // Power settings task
        {
            let cfg_clone = state.config.clone();
            let ft_clone = state.framework_tool.clone();
            tokio::spawn(async move {
                power::run(cfg_clone, ft_clone).await;
            });
        }

        // Battery settings task
        {
            let ft_clone = state.framework_tool.clone();
            let cfg_clone = state.config.clone();
            tokio::spawn(async move {
                battery::run(ft_clone, cfg_clone).await;
            });
        }

        // Telemetry task
        {
            let ft_clone = state.framework_tool.clone();
            let cfg_clone = state.config.clone();
            let samples_clone = state.telemetry_samples.clone();
            tokio::spawn(async move {
                telemetry::run(ft_clone, cfg_clone, samples_clone).await;
            });
        }
    }

    mod fan_curve {
        use super::*;
        pub async fn run(ft: Arc<RwLock<Option<cli::FrameworkTool>>>, cfg: Arc<RwLock<Config>>) {
            loop {
                let (mode, curve, manual_duty) = {
                    let c = cfg.read().await;
                    let mode = c.fan.mode.clone().unwrap_or(FanControlMode::Curve);
                    let curve = c.fan.curve.clone().unwrap_or_else(|| CurveConfig {
                        points: vec![[40, 20], [50, 30], [60, 40], [70, 60], [80, 80], [90, 100]],
                        ..Default::default()
                    });
                    let manual = c
                        .fan
                        .manual
                        .clone()
                        .unwrap_or(ManualConfig { duty_pct: 50 });
                    (mode, curve, manual.duty_pct)
                };

                match mode {
                    FanControlMode::Curve => {
                        if let Some(tool) = ft.read().await.as_ref() {
                            if let Ok(thermal) = tool.read_thermal().await {
                                let max_temp = thermal
                                    .sensors
                                    .iter()
                                    .map(|s| s.temp_c)
                                    .fold(f32::NEG_INFINITY, f32::max);

                                // Interpolate
                                let mut target_duty = 50.0;
                                let points = curve.points;
                                // Sort points just in case
                                let mut sorted_points = points.clone();
                                sorted_points.sort_by(|a, b| a[0].cmp(&b[0]));

                                for i in 0..sorted_points.len() {
                                    let p1 = sorted_points[i];
                                    if i == 0 && max_temp <= p1[0] as f32 {
                                        target_duty = p1[1] as f32;
                                        break;
                                    }
                                    if i == sorted_points.len() - 1 {
                                        target_duty = p1[1] as f32;
                                        break;
                                    }
                                    let p2 = sorted_points[i + 1];
                                    if max_temp >= p1[0] as f32 && max_temp <= p2[0] as f32 {
                                        let t1 = p1[0] as f32;
                                        let t2 = p2[0] as f32;
                                        let d1 = p1[1] as f32;
                                        let d2 = p2[1] as f32;
                                        let ratio = (max_temp - t1) / (t2 - t1);
                                        target_duty = d1 + (d2 - d1) * ratio;
                                        break;
                                    }
                                }
                                let _ = tool.set_fan_duty(target_duty as u32, None).await;
                            }
                        }
                    }
                    FanControlMode::Manual => {
                        if let Some(tool) = ft.read().await.as_ref() {
                            let _ = tool.set_fan_duty(manual_duty, None).await;
                        }
                    }
                    FanControlMode::Disabled => {
                        // Auto mode
                        if let Some(tool) = ft.read().await.as_ref() {
                            let _ = tool.set_fan_control_auto(None).await;
                        }
                    }
                }
                tokio::time::sleep(tokio::time::Duration::from_millis(2000)).await;
            }
        }
    }

    mod power {
        use super::*;
        pub async fn run(cfg: Arc<RwLock<Config>>, ft: Arc<RwLock<Option<cli::FrameworkTool>>>) {
            let _ = cfg;
            loop {

                tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
            }
        }
    }

    mod battery {
        use super::*;
        pub async fn run(ft: Arc<RwLock<Option<cli::FrameworkTool>>>, cfg: Arc<RwLock<Config>>) {
            loop {
                let limit_setting = {
                    let c = cfg.read().await;
                    c.battery.charge_limit_max_pct.clone()
                };

                if let Some(setting) = limit_setting {
                    if setting.enabled {
                        if let Some(tool) = ft.read().await.as_ref() {
                            let _ = tool.charge_limit_set(setting.value).await;
                        }
                    }
                }
                tokio::time::sleep(tokio::time::Duration::from_secs(60)).await;
            }
        }
    }

    mod telemetry {
        use super::*;
        pub async fn run(
            ft: Arc<RwLock<Option<cli::FrameworkTool>>>,
            cfg: Arc<RwLock<Config>>,
            samples: Arc<RwLock<std::collections::VecDeque<TelemetrySample>>>,
        ) {
            loop {
                let poll_ms = { cfg.read().await.telemetry.poll_ms };

                if let Some(tool) = ft.read().await.as_ref() {
                    if let Ok(thermal) = tool.read_thermal().await {
                        let mut temps = std::collections::BTreeMap::new();
                        for s in thermal.sensors {
                            temps.insert(s.name, s.temp_c as i32);
                        }
                        let rpms = thermal.fans.iter().map(|&f| f as u32).collect();

                        let sample = TelemetrySample {
                            ts_ms: chrono::Utc::now().timestamp_millis(),
                            temps,
                            rpms,
                        };

                        let mut s = samples.write().await;
                        s.push_back(sample);
                        if s.len() > 1800 {
                            s.pop_front();
                        }
                    }
                }
                tokio::time::sleep(tokio::time::Duration::from_millis(poll_ms)).await;
            }
        }
    }
}

struct FrameworkControlApp {
    state: AppState,
    runtime: tokio::runtime::Runtime,

    start_on_boot: bool,

    // Cached data
    thermal_data: Option<cli::framework_tool::ThermalParsed>,
    power_data: Option<cli::framework_tool::PowerBatteryInfo>,
    versions: Option<cli::framework_tool::Versions>,

    // Fan control settings
    fan_duty: u32,
    fan_enabled: bool,
    auto_fan: bool,
    fan_curve_enabled: bool,
    fan_curve: Vec<(f32, f32)>, // (temp_celsius, duty_percent)

    // Power settings
    tdp_watts: u32,
    thermal_limit: u32,
    power_enabled: bool,

    // Battery settings
    charge_limit: u8,
    charge_limit_enabled: bool,

    // Status messages
    status_message: String,

    // Advanced / BIOS features
    custom_command: String,
    command_output: String,
    keyboard_backlight_pct: u32,
}

impl FrameworkControlApp {
    fn new(
        cc: &eframe::CreationContext<'_>,
        state: AppState,
        runtime: tokio::runtime::Runtime,
    ) -> Self {
        // Set dark theme with Framework colors
        let mut style = (*cc.egui_ctx.style()).clone();

        // Premium Dark Theme
        let framework_orange = egui::Color32::from_rgb(255, 106, 0);
        let bg_color = egui::Color32::from_rgb(10, 10, 12); // Almost black
        let panel_color = egui::Color32::from_rgb(18, 18, 20); // Very dark gray
        let text_color = egui::Color32::from_rgb(240, 240, 245);
        let border_color = egui::Color32::from_rgb(40, 40, 45);

        // Apply dark theme
        style.visuals.dark_mode = true;
        style.visuals.override_text_color = Some(text_color);
        style.visuals.panel_fill = panel_color;
        style.visuals.window_fill = bg_color;
        style.visuals.extreme_bg_color = egui::Color32::BLACK;
        style.visuals.faint_bg_color = panel_color;

        // Borders
        style.visuals.window_stroke = egui::Stroke::new(1.0, border_color);
        style.visuals.widgets.noninteractive.bg_stroke = egui::Stroke::new(1.0, border_color);

        // Framework orange accents
        style.visuals.selection.bg_fill = framework_orange;
        style.visuals.selection.stroke = egui::Stroke::new(1.0, framework_orange);

        style.visuals.widgets.hovered.bg_fill = framework_orange.linear_multiply(0.2);
        style.visuals.widgets.hovered.bg_stroke = egui::Stroke::new(1.0, framework_orange);

        style.visuals.widgets.active.bg_fill = framework_orange.linear_multiply(0.4);
        style.visuals.widgets.active.bg_stroke = egui::Stroke::new(2.0, framework_orange);

        style.visuals.widgets.inactive.bg_fill = panel_color.linear_multiply(1.5); // Slightly lighter than panel
        style.visuals.widgets.inactive.bg_stroke = egui::Stroke::new(1.0, border_color);

        // Hyperlinks
        style.visuals.hyperlink_color = framework_orange;

        // Window rounding
        style.visuals.window_rounding = 8.0.into();
        style.visuals.menu_rounding = 6.0.into();

        // Spacing
        style.spacing.item_spacing = egui::vec2(8.0, 8.0);
        style.spacing.button_padding = egui::vec2(10.0, 6.0);

        cc.egui_ctx.set_style(style);

        // Check startup status
        let start_on_boot = check_start_on_boot();

        Self {
            state,
            runtime,
            start_on_boot,
            thermal_data: None,
            power_data: None,
            versions: None,
            fan_duty: 50,
            fan_enabled: false,
            auto_fan: true,
            fan_curve_enabled: false,
            fan_curve: vec![
                (40.0, 20.0),  // 40¬∞C -> 20% duty
                (50.0, 30.0),  // 50¬∞C -> 30% duty
                (60.0, 40.0),  // 60¬∞C -> 40% duty
                (70.0, 60.0),  // 70¬∞C -> 60% duty
                (80.0, 80.0),  // 80¬∞C -> 80% duty
                (90.0, 100.0), // 90¬∞C -> 100% duty
            ],
            tdp_watts: 15,
            thermal_limit: 80,
            power_enabled: false,
            charge_limit: 80,
            charge_limit_enabled: false,
            status_message: String::new(),
            custom_command: String::new(),
            command_output: String::new(),
            keyboard_backlight_pct: 50,
        }
    }

    fn update_data(&mut self, ctx: &egui::Context) {
        // Non-blocking update from cache
        if let Ok(cache) = self.state.cache.try_read() {
            if let Some(thermal) = &cache.thermal {
                self.thermal_data = Some(thermal.clone());
            }
            if let Some(power) = &cache.power {
                self.power_data = Some(power.clone());
            }
            if let Some(versions) = &cache.versions {
                self.versions = Some(versions.clone());
            }
        }
        ctx.request_repaint_after(std::time::Duration::from_millis(500));
    }
}

impl eframe::App for FrameworkControlApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        // Update data from background
        self.update_data(ctx);

        // Top panel - title and status
        egui::TopBottomPanel::top("top_panel").show(ctx, |ui| {
            ui.horizontal(|ui| {
                ui.heading("‚ö° Framework Control");
                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                    if let Some(versions) = &self.versions {
                        ui.label(format!(
                            "EC: {} | BIOS: {}",
                            versions.ec_version, versions.bios_version
                        ));
                    }
                });
            });

            if !self.status_message.is_empty() {
                ui.separator();
                ui.colored_label(egui::Color32::from_rgb(255, 165, 0), &self.status_message);
            }
        });

        // Central panel - all features in one view
        egui::CentralPanel::default().show(ctx, |ui| {
            egui::ScrollArea::vertical().show(ui, |ui| {
                ui.add_space(10.0);

                // 1. Dashboard (Temps, Power, Fans)
                self.show_dashboard(ui);

                ui.add_space(20.0);
                ui.separator();
                ui.add_space(10.0);

                // 2. Control Center (Curves, Limits)
                self.show_control_center(ui);

                ui.add_space(20.0);
                ui.separator();
                ui.add_space(10.0);

                // 3. Advanced / BIOS
                self.show_advanced_panel(ui);

                ui.add_space(20.0);
                ui.separator();
                ui.add_space(10.0);

                // System Info at bottom
                self.show_system(ui);
            });
        });
    }
}

impl FrameworkControlApp {
    fn show_temperature_panel(&mut self, ui: &mut egui::Ui) {
        ui.group(|ui| {
            ui.heading("üå°Ô∏è Temperatures");
            if let Some(thermal) = &self.thermal_data {
                egui::Grid::new("temps")
                    .num_columns(2)
                    .spacing([40.0, 4.0])
                    .show(ui, |ui| {
                        for sensor in &thermal.sensors {
                            ui.label(&sensor.name);
                            let temp = sensor.temp_c;
                            let color = if temp > 85.0 {
                                egui::Color32::RED
                            } else if temp > 75.0 {
                                egui::Color32::from_rgb(255, 165, 0)
                            } else {
                                egui::Color32::from_rgb(0, 200, 0)
                            };
                            ui.colored_label(color, format!("{:.1}¬∞C", temp));
                            ui.end_row();
                        }
                    });
            } else {
                ui.label("Install framework_tool");
            }
        });
    }

    fn show_fans_panel(&mut self, ui: &mut egui::Ui) {
        ui.group(|ui| {
            ui.heading("üåÄ Fans");
            if let Some(thermal) = &self.thermal_data {
                egui::Grid::new("fans")
                    .num_columns(2)
                    .spacing([40.0, 4.0])
                    .show(ui, |ui| {
                        for (idx, rpm) in thermal.fans.iter().enumerate() {
                            ui.label(format!("Fan {}", idx + 1));
                            ui.colored_label(
                                if *rpm > 4000.0 {
                                    egui::Color32::from_rgb(255, 165, 0)
                                } else {
                                    egui::Color32::from_rgb(100, 200, 255)
                                },
                                format!("{} RPM", rpm),
                            );
                            ui.end_row();
                        }
                    });
            }
        });
    }

    fn show_power_panel(&mut self, ui: &mut egui::Ui) {
        ui.group(|ui| {
            ui.heading("üîã Power");
            if let Some(power) = &self.power_data {
                egui::Grid::new("power")
                    .num_columns(2)
                    .spacing([40.0, 4.0])
                    .show(ui, |ui| {
                        ui.label("Status");
                        ui.colored_label(
                            if power.status == "Charging" {
                                egui::Color32::from_rgb(0, 200, 0)
                            } else {
                                egui::Color32::from_rgb(100, 150, 255)
                            },
                            &power.status,
                        );
                        ui.end_row();

                        {
                            let pct = power.charge_percent;
                            ui.label("Level");
                            ui.colored_label(
                                if pct < 20.0 {
                                    egui::Color32::RED
                                } else if pct < 50.0 {
                                    egui::Color32::from_rgb(255, 165, 0)
                                } else {
                                    egui::Color32::from_rgb(0, 200, 0)
                                },
                                format!("{:.1}%", pct),
                            );
                            ui.end_row();
                        }
                    });
            }
        });
    }

    // Enhanced fan control with grid-based curve editor
    fn show_fan_control_enhanced(&mut self, ui: &mut egui::Ui) {
        ui.heading("üåÄ Fan Control");
        ui.add_space(5.0);

        ui.horizontal(|ui| {
            if ui
                .radio(self.auto_fan && !self.fan_curve_enabled, "Auto")
                .clicked()
            {
                self.auto_fan = true;
                self.fan_curve_enabled = false;
            }
            if ui
                .radio(!self.auto_fan && !self.fan_curve_enabled, "Manual")
                .clicked()
            {
                self.auto_fan = false;
                self.fan_curve_enabled = false;
            }
            if ui
                .radio(!self.auto_fan && self.fan_curve_enabled, "Curve")
                .clicked()
            {
                self.auto_fan = false;
                self.fan_curve_enabled = true;
            }
        });

        ui.add_space(10.0);

        if self.auto_fan {
            ui.label("‚úì System controlled");
        } else if !self.fan_curve_enabled {
            ui.horizontal(|ui| {
                ui.label("Speed:");
                ui.add(egui::Slider::new(&mut self.fan_duty, 0..=100).suffix("%"));
            });
            if ui.button("‚ö° Apply").clicked() {
                self.apply_fan_speed();
            }
        } else {
            ui.label("Grid-based Fan Curve:");
            ui.add_space(5.0);

            egui::Grid::new("curve")
                .num_columns(3)
                .spacing([10.0, 5.0])
                .striped(true)
                .show(ui, |ui| {
                    ui.label("Temp (¬∞C)");
                    ui.label("Fan (%)");
                    ui.label("");
                    ui.end_row();

                    let mut to_remove = None;
                    let curve_len = self.fan_curve.len();
                    for (idx, (temp, duty)) in self.fan_curve.iter_mut().enumerate() {
                        ui.add(egui::DragValue::new(temp).speed(1.0).range(20.0..=100.0));
                        ui.add(egui::DragValue::new(duty).speed(1.0).range(0.0..=100.0));
                        if ui.small_button("‚úñ").clicked() && curve_len > 2 {
                            to_remove = Some(idx);
                        }
                        ui.end_row();
                    }

                    if let Some(idx) = to_remove {
                        self.fan_curve.remove(idx);
                    }
                });

            ui.add_space(5.0);
            ui.horizontal(|ui| {
                if ui.button("‚ûï Add Point").clicked() && self.fan_curve.len() < 10 {
                    let last = self.fan_curve.last().map(|(t, _)| *t).unwrap_or(50.0);
                    self.fan_curve.push(((last + 10.0).min(100.0), 50.0));
                    self.fan_curve
                        .sort_by(|a, b| a.0.partial_cmp(&b.0).unwrap());
                }
                if ui.button("‚ö° Apply Curve").clicked() {
                    self.apply_fan_curve();
                }
            });
        }

        ui.add_space(5.0);
        if !self.auto_fan && ui.button("üîÑ Reset Auto").clicked() {
            self.reset_fan_to_auto();
        }
    }

    fn show_power_battery_control(&mut self, ui: &mut egui::Ui) {
        ui.heading("‚ö° Power");
        ui.checkbox(&mut self.power_enabled, "Custom Limits");
        ui.add_enabled_ui(self.power_enabled, |ui| {
            ui.horizontal(|ui| {
                ui.label("TDP:");
                ui.add(egui::Slider::new(&mut self.tdp_watts, 5..=28).suffix("W"));
            });
            ui.horizontal(|ui| {
                ui.label("Thermal:");
                ui.add(egui::Slider::new(&mut self.thermal_limit, 60..=100).suffix("¬∞C"));
            });
            if ui.button("‚ö° Apply").clicked() {
                self.apply_power_settings();
            }
        });
        ui.separator();
        ui.heading("üîã Battery");
        ui.checkbox(&mut self.charge_limit_enabled, "Charge Limit");
        ui.add_enabled_ui(self.charge_limit_enabled, |ui| {
            ui.horizontal(|ui| {
                ui.label("Max:");
                ui.add(egui::Slider::new(&mut self.charge_limit, 50..=100).suffix("%"));
            });
            if ui.button("üîã Apply").clicked() {
                self.apply_charge_limit();
            }
        });
    }

    // Action methods
    fn apply_fan_speed(&mut self) {
        let duty = self.fan_duty;
        let state = self.state.clone();
        self.runtime.spawn(async move {
            if let Some(ft) = state.framework_tool.read().await.as_ref() {
                match ft.set_fan_duty(duty, None).await {
                    Ok(_) => tracing::info!("‚úì Fan duty set to {}%", duty),
                    Err(e) => tracing::error!("Failed to set fan: {}", e),
                }
            }
        });
        self.fan_enabled = true;
        self.status_message = format!("‚úì Fan: {}%", duty);
    }

    fn reset_fan_to_auto(&mut self) {
        let state = self.state.clone();
        self.runtime.spawn(async move {
            if let Some(ft) = state.framework_tool.read().await.as_ref() {
                match ft.set_fan_control_auto(None).await {
                    Ok(_) => tracing::info!("‚úì Fan reset to auto"),
                    Err(e) => tracing::error!("Failed to reset fan: {}", e),
                }
            }
        });
        self.fan_enabled = false;
        self.auto_fan = true;
        self.status_message = "‚úì Fan: Auto".to_string();
    }

    fn apply_fan_curve(&mut self) {
        self.fan_curve
            .sort_by(|a, b| a.0.partial_cmp(&b.0).unwrap());
        let curve = self.fan_curve.clone();
        let state = self.state.clone();

        self.runtime.spawn(async move {
            loop {
                if let Some(ft) = state.framework_tool.read().await.as_ref() {
                    if let Ok(thermal) = ft.read_thermal().await {
                        let max_temp = thermal
                            .sensors
                            .iter()
                            .map(|s| s.temp_c)
                            .fold(f32::NEG_INFINITY, f32::max);

                        let mut duty = 50.0;
                        for i in 0..curve.len() {
                            if i == 0 && max_temp <= curve[i].0 {
                                duty = curve[i].1;
                                break;
                            }
                            if i == curve.len() - 1 && max_temp >= curve[i].0 {
                                duty = curve[i].1;
                                break;
                            }
                            if i < curve.len() - 1
                                && max_temp >= curve[i].0
                                && max_temp <= curve[i + 1].0
                            {
                                let t1 = curve[i].0;
                                let t2 = curve[i + 1].0;
                                let d1 = curve[i].1;
                                let d2 = curve[i + 1].1;
                                let ratio = (max_temp - t1) / (t2 - t1);
                                duty = d1 + (d2 - d1) * ratio;
                                break;
                            }
                        }

                        let _ = ft.set_fan_duty(duty as u32, None).await;
                        tracing::debug!("Fan curve: {}¬∞C -> {}%", max_temp, duty as u32);
                    }
                }
                tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
            }
        });

        self.status_message = "‚úì Curve active".to_string();
    }

    fn apply_power_settings(&mut self) {
        let (tdp, thermal, state) = (self.tdp_watts, self.thermal_limit, self.state.clone());
        self.runtime.spawn(async move {
            if let Some(ft) = state.framework_tool.read().await.as_ref() {
                // TODO: Implement power settings via framework_tool
                // let _ = ft.set_tdp_watts(tdp).await;
                // let _ = ft.set_thermal_limit_c(thermal).await;
                tracing::info!(
                    "‚úì Power settings requested: {}W, {}¬∞C (not yet implemented)",
                    tdp,
                    thermal
                );
            }
        });
        self.status_message = format!("‚úì Power: {}W/{}¬∞C", tdp, thermal);
    }

    fn show_dashboard(&mut self, ui: &mut egui::Ui) {
        ui.heading("üìä Dashboard");
        ui.add_space(5.0);

        egui::Grid::new("dashboard_grid")
            .num_columns(2)
            .spacing([20.0, 20.0])
            .show(ui, |ui| {
                // Top Left: Temperatures
                ui.vertical(|ui| {
                    self.show_temperature_panel(ui);
                });

                // Top Right: Power Status
                ui.vertical(|ui| {
                    self.show_power_panel(ui);
                });
                ui.end_row();

                // Bottom: Fans (spanning 2 columns if possible, or just left)
                ui.vertical(|ui| {
                    self.show_fans_panel(ui);
                });
                ui.end_row();
            });
    }

    fn show_control_center(&mut self, ui: &mut egui::Ui) {
        ui.heading("üéõÔ∏è Control Center");
        ui.add_space(5.0);

        ui.columns(2, |columns| {
            columns[0].group(|ui| {
                self.show_fan_control_enhanced(ui);
            });
            columns[1].group(|ui| {
                self.show_power_battery_control(ui);
            });
        });
    }

    fn show_advanced_panel(&mut self, ui: &mut egui::Ui) {
        ui.heading("üõ†Ô∏è Advanced / BIOS");
        ui.add_space(5.0);

        ui.group(|ui| {
            ui.label("Experimental Features");
            ui.separator();

            // Keyboard Backlight (Placeholder)
            ui.horizontal(|ui| {
                ui.label("Keyboard Backlight:");
                ui.add(egui::Slider::new(&mut self.keyboard_backlight_pct, 0..=100).suffix("%"));
                if ui.button("Set").clicked() {
                    // TODO: Implement actual call
                    self.status_message = format!(
                        "Backlight set to {}% (Simulated)",
                        self.keyboard_backlight_pct
                    );
                }
            });

            ui.add_space(10.0);
            ui.separator();

            // Custom Command Runner
            ui.label("Custom framework_tool Command:");
            ui.horizontal(|ui| {
                ui.text_edit_singleline(&mut self.custom_command);
                if ui.button("Run").clicked() {
                    self.run_custom_command();
                }
            });

            if !self.command_output.is_empty() {
                ui.add_space(5.0);
                ui.label("Output:");
                egui::ScrollArea::vertical()
                    .max_height(100.0)
                    .show(ui, |ui| {
                        ui.monospace(&self.command_output);
                    });
            }
        });
    }

    fn run_custom_command(&mut self) {
        let cmd = self.custom_command.clone();
        if cmd.trim().is_empty() {
            return;
        }

        let state = self.state.clone();
        self.command_output =
            "Command sent (async). Output logging not yet linked to UI.".to_string();

        self.runtime.spawn(async move {
            let args: Vec<String> = cmd.split_whitespace().map(String::from).collect();
            if let Some(ft) = state.framework_tool.read().await.as_ref() {
                match ft.run_raw_command(args).await {
                    Ok(o) => tracing::info!("Custom Command Output:\n{}", o),
                    Err(e) => tracing::error!("Custom Command Error: {}", e),
                }
            }
        });
    }

    fn apply_charge_limit(&mut self) {
        let limit = self.charge_limit;
        let state = self.state.clone();
        self.runtime.spawn(async move {
            if let Some(ft) = state.framework_tool.read().await.as_ref() {
                match ft.charge_limit_set(limit).await {
                    Ok(_) => tracing::info!("‚úì Charge limit set to {}%", limit),
                    Err(e) => tracing::error!("Failed to set charge limit: {}", e),
                }
            }
        });
        self.status_message = format!("‚úì Charge Limit: {}%", limit);

        // Save config
        let mut cfg = self.state.config.blocking_write();
        cfg.battery.charge_limit_max_pct = Some(SettingU8 {
            enabled: true,
            value: limit,
        });
        config::save(&cfg);
    }

    fn show_system(&mut self, ui: &mut egui::Ui) {
        ui.group(|ui| {
            ui.horizontal(|ui| {
                ui.heading("‚ÑπÔ∏è System");
                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                    ui.label(format!("v{}", env!("CARGO_PKG_VERSION")));
                });
            });

            if let Some(v) = &self.versions {
                ui.horizontal(|ui| {
                    ui.label(format!("UEFI: {}", v.bios_version));
                    ui.separator();
                    ui.label(format!("EC: {}", v.ec_version));
                });
            }

            ui.separator();
            if ui
                .checkbox(&mut self.start_on_boot, "Start on Startup")
                .changed()
            {
                set_start_on_boot(self.start_on_boot);
                // Save config (optional, but good for consistency)
                let mut cfg = self.state.config.blocking_write();
                cfg.start_on_boot = self.start_on_boot;
                config::save(&cfg);
            }
        });
    }
}

fn check_start_on_boot() -> bool {
    std::process::Command::new("reg")
        .args(&[
            "query",
            "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run",
            "/v",
            "FrameworkControl",
        ])
        .output()
        .map(|o| o.status.success())
        .unwrap_or(false)
}

fn set_start_on_boot(enable: bool) {
    let exe_path = std::env::current_exe().unwrap_or_default();
    let exe_str = exe_path.to_string_lossy();

    if enable {
        let _ = std::process::Command::new("reg")
            .args(&[
                "add",
                "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run",
                "/v",
                "FrameworkControl",
                "/t",
                "REG_SZ",
                "/d",
                &format!("\"{}\" --minimized", exe_str),
                "/f",
            ])
            .output();
    } else {
        let _ = std::process::Command::new("reg")
            .args(&[
                "delete",
                "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run",
                "/v",
                "FrameworkControl",
                "/f",
            ])
            .output();
    }
}